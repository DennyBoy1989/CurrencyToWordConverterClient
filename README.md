# CurrencyToWordConverterClient
A WPF Windows App that represents the UI for [CurencyToWordConverterAPI](https://github.com/DennyBoy1989/CurrencyToWordConverter).
## Exposition
This is an example WPF client application, that uses the [CurencyToWordConverterAPI](https://github.com/DennyBoy1989/CurrencyToWordConverter) web API, to convert a currency into its word representation. It was created as part of the application process for a Software Developer position at Qoniac GmbH, a KLA Company. As a web developer, that normally uses .NET vor backends and Javascript frameworks like Angular, Vue or React for frontends, this was the very first WPF application, that I created ever. However, I have tried to convey concepts like MVVM, that I know from the former mentioned frameworks, to the WPF world. 

## How to run it
First clone this repository and open in your favorite IDE. Since this application requires a running /wordrepresentation endpoint of the [CurencyToWordConverterAPI](https://github.com/DennyBoy1989/CurrencyToWordConverter), the next step should be, to checkout the CurencyToWordConverterAPI and get it running with the https profile (check the readme of that project as well). If you didn't change the ports and just started the API project, the endpoint will available on port 7107 ("https://localhost:7107/wordrepresentation"). This endpoint is already set as default in the appsettings.json of the client project. If you run the API on a different port, open the appsettings.json of the client and change the property externalServices:currencyToWordConverterApi:baseUrl to that port. When the API is running and the port is correctly set, you can start the WPF application.

## Principles
This project is very small, but I tried to demonstrate some principiles, that I like to use:
### Model-View-Viewmodel
In the frameworks Angular and Vue you normally work with Viewmodels, that hold the states, that are bound to your view. This decouples the display logic from the actual logic, that executes, when the user interacts, with the UI and also makes it more testable. I really like this principle and there is support for this pattern in WPF applications. So I imported the Community Toolkit MVVM into the project and created a CurrencyToWordConverterVm, which is the ViewModel of the MainWindow.xaml.
### Clean Architecture
I really like the 'Clean Architecture' design conceived by Robert C. Martin. In short, it says, that you have a business/domain core and all other layers like datasbases, web APIs or view, should depend on it. The business/domain core contains the models and the core logic of the application and is unware of the other layers. It does provide interfaces, that the other layers can implement, though. To enforce this seperation, I usually like to devide my C# projects into multiple assemblies. So, even though the CurrencyToWordConverterClient is very small, I have three assemblies. One for WPF logic (view), on for the adapter logic to the Web API and one for the domain core.
### Grey-Box-Testing
Another aspect, that is worth mentioning, is the way I like to unit test. After many years of heavy white box testing, I decided to switch to an approach, that focuses more on the result of a test, then the behaviour of the code. On the same time, I know the code, and I know, which inputs I need, to test the edge cases. This is sometimes called Grey-Box-Testing. In the last years I extended the approach by using stubs for the IO-Interfaces and relay on the actual implementations of all classes instead of writing a mock for every dependency, that a class under test has. So my tests mostly create the input and configure the IO stubs (comparable to an in-memory database) in the "arrange"-phase and are then executed pretty straightforward.
